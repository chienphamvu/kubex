#!/bin/bash

# Check if KUBEX_ISOLATED is set to true
if [ "$KUBEX_ISOLATED" = "true" ]; then
  # Use the terminal session ID to isolate the namespace list
  session_id=$(tty | sed 's/\/dev\///')
  last_list_file="/tmp/last_list_${session_id}.txt"
else
  last_list_file="/tmp/last_list.txt"
fi

# Create a temporary file to store context and namespace for the session
session_id=$(tty | sed 's/\/dev\///' | tr -cd A-Za-z0-9_)
session_config_file="/tmp/kubex_session_${session_id}.conf"

# Function to write context and namespace to the session config file
write_session_config() {
  echo "context: $1" > "$session_config_file"
  echo "namespace: $2" >> "$session_config_file"
}

# Function to read context and namespace from the session config file
read_session_config() {
  if [ -f "$session_config_file" ]; then
    CONTEXT=$(grep "context:" "$session_config_file" | awk -F': ' '{print $2}')
    NAMESPACE=$(grep "namespace:" "$session_config_file" | awk -F': ' '{print $2}')
  fi
}

COMMAND=$1
shift

grep_and_switch_namespace() {
  local namespace_substring=$1
  MATCH=""

  # Read existing context and namespace from session config
  read_session_config

  local namespaces_file="/tmp/namespaces_$(kubectl config current-context).txt"

  if [[ $namespace_substring =~ ^[0-9]+$ ]]; then
    namespace_substring=$(get_item_name "$namespace_substring")
  fi

  if ! ([ -f "$namespaces_file" ]) || ([ -f "$namespaces_file" ] && ! grep -q "$namespace_substring" "$namespaces_file"); then
    touch "$namespaces_file"
    echo "Getting namespaces..."
    kubectl get namespaces > "$namespaces_file"
  fi

  handle_matching "$namespace_substring" "$namespaces_file" "namespace"

  # switch default namespace
  if [ -n "$MATCH" ]; then
    NAMESPACE="$MATCH"
    echo "Switched default namespace to $MATCH (session-only)"
    write_session_config "$CONTEXT" "$NAMESPACE"
  else
    echo "No namespace matches '$namespace_substring'!"
    exit 1
  fi
}

make_list_numbered() {
  local line_number=-1
  local tmpfile=$(mktemp)

  while IFS= read -r line; do
    if [[ "$line_number" -eq -1 ]]; then
      echo "$line" >> "$tmpfile"
    elif [[ "$line_number" -eq 0 ]]; then
      printf "  %s\n" "$line" >> "$tmpfile"
    else
      printf "%d %s\n" "$line_number" "$line" >> "$tmpfile"
    fi
    ((line_number++))
  done < "$last_list_file"

  mv "$tmpfile" "$last_list_file"
}

get_item_name() {
  local line_number="$1"

  item_name=$(awk -v line_num="$line_number" '$1 == line_num {print $2}' "$last_list_file" | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g')

  if [[ -n "$item_name" ]]; then
    echo "$item_name"
  else
    echo "Error: '$line_number' does not exist!"
    exit 1
  fi
}

list_items() {
  local object=$1
  local namespace_arg=$2
  local context_arg=$3

  shift 3

  if [ "$KUBEX_ISOLATED" = "true" ]; then
    local args=("$namespace_arg" "$context_arg")
  else
    local args=()
  fi

  if [[ "$@" == *"-w"* ]] || [[ "$@" == "--watch" ]]; then
    kubecolor get "$object" "${args[@]}" "$@"
  else
    echo "$object" > $last_list_file
    kubecolor get "$object" --force-colors ${args[@]} "$@" >> $last_list_file
    make_list_numbered $last_list_file
    tail -n +2 $last_list_file
  fi
}

get_last_object_type() {
  head -n 1 "$last_list_file"
}

grep_and_switch_cluster() {
  local cluster=$1
  MATCH=""

  # Read existing context and namespace from session config
  read_session_config

  handle_matching "$cluster" "$(kubectl config get-contexts --output=name)" "cluster"
  CONTEXT="$MATCH"
  write_session_config "$CONTEXT" "$NAMESPACE"
}

get_object_details() {
  local item_number=$1
  OBJECT_TYPE=$(get_last_object_type)
  ITEM_NAME=$(get_item_name "$item_number")
}

construct_gcp_url() {
  local cluster_project="$1"
  local namespace="$2"
  local item_name="$3"
  local log_type="$4"
  local url=""

  if [[ "$log_type" == "logs" ]]; then
    url="https://console.cloud.google.com/logs/query;query=logName%3D%2528%22projects%2F${cluster_project}%2Flogs%2Fstderr%22%20OR%20%22projects%2F${cluster_project}%2Flogs%2Fstdout%22%2529%0Aresource.labels.namespace_name%3D%22${namespace}%22%0Aresource.labels.pod_name%3D%22${item_name}%22%0Aresource.labels.container_name!%3D%22istio-proxy%22;duration=PT30M?referrer=search&project=${cluster_project}"
  elif [[ "$log_type" == "metrics" ]]; then
    url="https://console.cloud.google.com/monitoring/metrics-explorer;duration=PT1H?referrer=search&project=${cluster_project}&pageState=%7B%22xyChart%22:%7B%22constantLines%22:%5B%5D,%22dataSets%22:%5B%7B%22plotType%22:%22LINE%22,%22targetAxis%22:%22Y1%22,%22timeSeriesFilter%22:%7B%22aggregations%22:%5B%7B%22crossSeriesReducer%22:%22REDUCE_MEAN%22,%22groupByFields%22:%5B%22resource.label.%5C%22container_name%5C%22%22%5D,%22perSeriesAligner%22:%22ALIGN_MEAN%22%7D%5D,%22apiSource%22:%22DEFAULT_CLOUD%22,%22crossSeriesReducer%22:%22REDUCE_MEAN%22,%22filter%22:%22metric.type%3D%5C%22kubernetes.io%2Fcontainer%2Fmemory%2Fused_bytes%5C%22%20resource.type%3D%5C%22k8s_container%5C%22%20metric.label.%5C%22memory_type%5C%22%3D%5C%22non-evictable%5C%22%20resource.label.%5C%22namespace_name%5C%22%3D%5C%22${namespace}%5C%22%20resource.label.%5C%22container_name%5C%22!%3D%5C%22istio-proxy%5C%22%20resource.label.%5C%22pod_name%5C%22%3D%5C%22${item_name}%5C%22%22,%22groupByFields%22:%5B%22resource.label.%5C%22container_name%5C%22%22%5D,%22minAlignmentPeriod%22:%2260s%22,%22perSeriesAligner%22:%22ALIGN_MEAN%22%7D%7D,%7B%22plotType%22:%22LINE%22,%22targetAxis%22:%22Y1%22,%22timeSeriesFilter%22:%7B%22aggregations%22:%5B%7B%22crossSeriesReducer%22:%22REDUCE_MEAN%22,%22groupByFields%22:%5B%22resource.label.%5C%22container_name%5C%22%22%5D,%22perSeriesAligner%22:%22ALIGN_MEAN%22%7D%5D,%22apiSource%22:%22DEFAULT_CLOUD%22,%22crossSeriesReducer%22:%22REDUCE_MEAN%22,%22filter%22:%22metric.type%3D%5C%22kubernetes.io%2Fcontainer%2Fmemory%2Flimit_bytes%5C%22%20resource.type%3D%5C%22k8s_container%5C%22%20resource.label.%5C%22namespace_name%5C%22%3D%5C%22${namespace}%5C%22%20resource.label.%5C%22container_name%5C%22!%3D%5C%22istio-proxy%5C%22%20resource.label.%5C%22pod_name%5C%22%3D%5C%22${item_name}%5C%22%22,%22groupByFields%22:%5B%22resource.label.%5C%22container_name%5C%22%22%5D,%22minAlignmentPeriod%22:%2260s%22,%22perSeriesAligner%22:%22ALIGN_MEAN%22%7D%7D,%7B%22plotType%22:%22LINE%22,%22targetAxis%22:%22Y1%22,%22timeSeriesFilter%22:%7B%22aggregations%22:%5B%7B%22crossSeriesReducer%22:%22REDUCE_MEAN%22,%22groupByFields%22:%5B%22resource.label.%5C%22container_name%5C%22%22%5D,%22perSeriesAligner%22:%22ALIGN_MEAN%22%7D%5D,%22apiSource%22:%22DEFAULT_CLOUD%22,%22crossSeriesReducer%22:%22REDUCE_MEAN%22,%22filter%22:%22metric.type%3D%5C%22kubernetes.io%2Fcontainer%2Fmemory%2Frequest_bytes%5C%22%20resource.type%3D%5C%22k8s_container%5C%22%20resource.label.%5C%22namespace_name%5C%22%3D%5C%22${namespace}%5C%22%20resource.label.%5C%22container_name%5C%22!%3D%5C%22istio-proxy%5C%22%20resource.label.%5C%22pod_name%5C%22%3D%5C%22${item_name}%5C%22%22,%22groupByFields%22:%5B%22resource.label.%5C%22container_name%5C%22%22%5D,%22minAlignmentPeriod%22:%2260s%22,%22perSeriesAligner%22:%22ALIGN_MEAN%22%7D%7D%5D,%22options%22:%7B%22mode%22:%22COLOR%22%7D,%22y1Axis%22:%7B%22label%22:%22%22,%22scale%22:%22LINEAR%22%7D%7D%7D&inv=1&invt=AbqsyA"
  fi

  echo "$url"
}

handle_matching() {
  local grep_string="$1"
  local file="$2"
  local resource_type="$3"

  if [[ -z "$grep_string" || -z "$file" ]]; then
    echo "Usage: $0 <grep_string> <file>"
    exit 1
  fi

  if [[ ! -f "$file" ]]; then
    matching_lines=$(echo "$file" | grep -n "$grep_string")
  else
    matching_lines=$(tail -n +2 "$file" | grep -n "$grep_string")
  fi

  if [[ -z "$matching_lines" ]]; then
    echo "No matching ${resource_type} found."
    exit 0
  fi

  line_count=$(echo "$matching_lines" | wc -l)

  if [[ "$line_count" -eq 1 ]]; then
    MATCH=$(echo "$matching_lines" | cut -d':' -f2- | awk '{print $1}')
  elif [[ "$line_count" -gt 1 ]]; then
    echo "Multiple matching ${resource_type} found:"
    echo
    echo "$matching_lines" | awk -F: '{print $1 ". " $2}' | awk '{print $1 " " $2}'
    echo

    read -p "Enter the line number to select: " selected_line_number

    MATCH=$(echo "$matching_lines" | awk -F: -v line_num="$selected_line_number" '$1 == line_num {print $2}' | awk '{print $1}')
  else
    echo "Error: Unexpected condition."
    exit 1
  fi
}

show_last_list() {
  local grep_string="$1"

  if [ -n $1 ]; then
    cat "$last_list_file" | grep "$1"
  else
    cat "$last_list_file"
  fi
}

###############
#   COMMANDS
###############
handle_get() {
  local OBJECT=$1
  local ALL_NAMESPACES_OPTIONS
  local switch_ns
  local grep_string
  local namespace_substring
  local switch_ctx
  local context_substring

  shift

  # Read existing context and namespace from session config
  read_session_config

  if [[ "$OBJECT" == "last" ]]; then
    show_last_list "$@"
    exit 0
  fi

  if [[ "$1" == "in" ]]; then
    if [[ "$2" == "all" ]]; then
      ALL_NAMESPACES_OPTIONS="--all-namespaces"
    else
      switch_ns=true
      namespace_substring="$2"
    fi
    shift 2
  fi

  if [[ "$1" == "on" ]]; then
    switch_ctx=true
    context_substring="$2"
    shift 2
  fi

  if [ -n "$switch_ns" ]; then
    grep_and_switch_namespace "$namespace_substring"
  fi

  if [ -n "$switch_ctx" ]; then
    grep_and_switch_cluster "$context_substring"
  fi

  if [[ -n "$1" ]] && [[ "$1" != -* ]]; then
    grep_string="$1"
    shift
  fi

  case "$OBJECT" in
    "p") OBJECT="pod"
    ;;
    "d") OBJECT="deployment"
    ;;
    "svc") OBJECT="service"
    ;;
    "sa") OBJECT="ServiceAccount"
    ;;
    "a") OBJECT="applications"
    ;;
    "vs") OBJECT="VirtualServices"
    ;;
    "mc") OBJECT="ManagedCertificate"
    ;;
    "se") OBJECT="ServiceEntry"
    ;;
    "sec") OBJECT="secret"
    ;;
    "ss") OBJECT="StatefulSets"
    ;;
    "ds") OBJECT="DaemonSets"
    ;;
    "rs") OBJECT="ReplicaSets"
    ;;
    "rc") OBJECT="ReplicaControllers"
    ;;
    "j") OBJECT="job"
    ;;
    "cj") OBJECT="cronjob"
    ;;
    "gw") OBJECT="gateway"
    ;;
    "i") OBJECT="ingress"
    ;;
    "bc") OBJECT="BackendConfig"
    ;;
    "dr") OBJECT="DestinationRule"
    ;;
    "rb") OBJECT="rolebinding"
    ;;
    "r") OBJECT="roles"
    ;;
    "crb") OBJECT="clusterrolebinding"
    ;;
    "cr") OBJECT="clusterroles"
    ;;
  esac

  if [ -n "$NAMESPACE" ]; then
    namespace_arg="--namespace=$NAMESPACE"
  fi

  if [ -n "$CONTEXT" ]; then
    context_arg="--context=$CONTEXT"
  fi

  if [ -n "$grep_string" ]; then
    list_items "$OBJECT" "$ALL_NAMESPACES_OPTIONS" "$namespace_arg" "$context_arg" $@ | grep "$grep_string"
  else
    list_items "$OBJECT" "$ALL_NAMESPACES_OPTIONS" "$namespace_arg" "$context_arg" $@
  fi
}

handle_describe() {
  local item_number=$1
  shift

  # Read existing context and namespace from session config
  read_session_config

  if [ -z "$item_number" ]; then
      kubecolor describe
      exit 1
  fi
 
  get_object_details "$item_number"
 
  set -x
  kubecolor describe --context="$CONTEXT" --namespace="$NAMESPACE" "$OBJECT_TYPE" "$ITEM_NAME" "$@"
}

handle_delete() {
  local item_number=$1
  shift

  if [ -z "$item_number" ]; then
      kubecolor delete
      exit 1
  fi

  get_object_details "$item_number"

  read -p "Delete $OBJECT_TYPE $ITEM_NAME (y/N)? " -r REPLY
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
    set -x
    kubecolor delete "$OBJECT_TYPE" "$ITEM_NAME" "$@"
  else
    echo "Keep it then!"
  fi
}

handle_edit() {
  local item_number=$1
  shift

  # Read existing context and namespace from session config
  read_session_config

  if [ -z "$item_number" ]; then
      kubectl edit
      exit 1
  fi
 
  get_object_details "$item_number"
 
  set -x
  kubectl edit --context="$CONTEXT" --namespace="$NAMESPACE" "$OBJECT_TYPE" "$ITEM_NAME"
}

handle_top() {
  local item_number=$1
  shift
  local current_context
  local namespace
  local cluster_project

  # Read existing context and namespace from session config
  read_session_config

  if [ -z "$item_number" ]; then
      kubecolor top
      exit 1
  fi
 
  get_object_details "$item_number"
 
  if [[ "$@" == *"--gcp"* ]]; then
    current_context=$(kubectl config get-contexts | grep "*")
    namespace=$(echo "$current_context" | awk '{print $5}')
    cluster_project=$(echo "$current_context" | awk '{print $3}' | awk -F'_' '{print $2}')
 
    url=$(construct_gcp_url "$cluster_project" "$namespace" "$ITEM_NAME" "metrics")
 
    open_gcp_console_url "$url"
 
    exit 0
  fi
 
  set -x
  kubecolor top --context="$CONTEXT" --namespace="$NAMESPACE" "$OBJECT_TYPE" "$ITEM_NAME" "$@"
}

handle_switch() {
  local context_name=$1

  # Read existing context and namespace from session config
  read_session_config

  kubectl config use-context "$context_name"
  CONTEXT="$context_name"
  kubectl get namespaces > "/tmp/namespaces_$(kubectl config current-context).txt"
  write_session_config "$CONTEXT" "$NAMESPACE"
}

handle_logs() {
  local item_number=$1
  shift
  local current_context
  local namespace
  local cluster_project

  # Read existing context and namespace from session config
  read_session_config

  if [ -z "$item_number" ]; then
      kubecolor logs
      exit 1
  fi
 
  get_object_details "$item_number"
 
  if [[ "$@" == *"--gcp"* ]]; then
    current_context=$(kubectl config get-contexts | grep "*")
    namespace=$(echo "$current_context" | awk '{print $5}')
    cluster_project=$(echo "$current_context" | awk '{print $3}' | awk -F'_' '{print $2}')
 
    url=$(construct_gcp_url "$cluster_project" "$namespace" "$ITEM_NAME" "logs")
 
    open_gcp_console_url "$url"
 
    exit 0
  fi
 
  local tail_option=""
  if [[ "$@" == *"-f"* ]] || [[ "$@" == "--follow=true" ]]; then
    # By default, get only the last 50 line of logs if not streaming
    tail_option="--tail=50"
 
    if [[ "$@" == *"--tail"* ]]; then
      tail_option=""
    fi
  fi
 
  set -x
  kubectl logs --context="$CONTEXT" --namespace="$NAMESPACE" "$OBJECT_TYPE"/"$ITEM_NAME" $tail_option "$@"
}

handle_rr() {
  local item_number=$1
  local object_type
  local item_name

  if [ -z "$item_number" ]; then
      kubecolor rollout restart
      exit 1
  fi

  if [[ $item_number =~ ^[0-9]+$ ]]; then
    object_type=$(get_last_object_type)
    item_name=$(get_item_name "$item_number")
    set -x
    kubecolor rollout restart "$object_type"/"$item_name"
  else
    set -x
    kubecolor rollout restart "$item_number"
  fi
}

handle_events() {
  item_number=$1
  shift

  # Read existing context and namespace from session config
  read_session_config

  if [ -z "$item_number" ]; then
      kubecolor events
      exit 1
  fi
 
  local object_type=$(get_last_object_type)
  local item_name=$(get_item_name "$item_number")
 
  set -x
  kubecolor events --context="$CONTEXT" --namespace="$NAMESPACE" --for "$object_type"/"$item_name" "$@"
}

handle_exec() {
  local item_number=$1
  shift

  kubectl exec -t -i $(get_item_name $item_number) "$@" -- sh -c "(bash || ash || sh)"
}

case "$COMMAND" in
  "get")
    handle_get "$@"
    ;;
  "describe")
    handle_describe "$@"
    ;;
  "delete")
    handle_delete "$@"
    ;;
  "edit")
    handle_edit "$@"
    ;;
  "top")
    handle_top "$@"
    ;;
  "switch")
    handle_switch "$@"
    ;;
  "logs")
    handle_logs "$@"
    ;;
  "rr")
    handle_rr "$@"
    ;;
  "events")
    handle_events "$@"
    ;;
  "exec")
    handle_exec "$@"
    ;;
  *)
    echo "Invalid command: $COMMAND"
    exit 1
    ;;
esac
